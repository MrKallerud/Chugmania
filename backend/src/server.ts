import { asc, eq, isNull } from 'drizzle-orm'
import express from 'express'
import { Server } from 'socket.io'
import ViteExpress from 'vite-express'
import {
  WS_CONNECT_NAME,
  WS_DISCONNECT_NAME,
} from '../../common/utils/constants'
import db from '../database/database'
import { sessions } from '../database/schema'
import ConnectionManager from './managers/connection.manager'

const PORT = process.env.PORT ? Number.parseInt(process.env.PORT) : 6996
const app = express()

app.get('/api/sessions/calendar.ics', async (req, res) => {
  try {
    const sessionRows = await db
      .select()
      .from(sessions)
      .where(isNull(sessions.deletedAt))
      .orderBy(asc(sessions.date), asc(sessions.createdAt))

    const calendar = createSessionsCalendar(
      sessionRows,
      req.protocol,
      req.get('host'),
      'Chugmania Sessions'
    )

    res
      .type('text/calendar; charset=utf-8')
      .setHeader('Content-Disposition', 'inline; filename="sessions.ics"')
      .setHeader('Cache-Control', 'no-store')
      .send(calendar)
  } catch (error) {
    logError('Failed to create sessions calendar', error)
    res.status(500).send('Failed to load sessions calendar')
  }
})

app.get('/api/sessions/:id/calendar.ics', async (req, res) => {
  try {
    const sessionId = req.params.id
    if (!sessionId) {
      res.status(400).send('Session id is required')
      return
    }

    const session = await db.query.sessions.findFirst({
      where: eq(sessions.id, sessionId),
    })

    if (!session || session.deletedAt) {
      res.status(404).send('Session not found')
      return
    }

    const calendar = createSessionsCalendar(
      [session],
      req.protocol,
      req.get('host'),
      session.name
    )
    res
      .type('text/calendar; charset=utf-8')
      .setHeader(
        'Content-Disposition',
        `inline; filename="session-${session.id}.ics"`
      )
      .setHeader('Cache-Control', 'no-store')
      .send(calendar)
  } catch (error) {
    logError('Failed to create session calendar', error)
    res.status(500).send('Failed to load session calendar')
  }
})

const server = ViteExpress.listen(app, PORT)
const io = new Server(server, {
  cors: {
    origin: [process.env.ORIGIN ?? 'http://localhost:' + PORT],
    credentials: true,
  },
})

io.on(WS_CONNECT_NAME, s =>
  ConnectionManager.connect(s).then(() => {
    s.on(WS_DISCONNECT_NAME, () => ConnectionManager.disconnect(s))
  })
)

function escapeICSText(value: string) {
  return value
    .replaceAll(/\\/g, String.raw`\\`)
    .replaceAll(/\n/g, String.raw`\\n`)
    .replaceAll(/,/g, String.raw`\\,`)
    .replaceAll(/;/g, String.raw`\\;`)
}

function formatICSDate(date: Date) {
  return date
    .toISOString()
    .replaceAll(/[-:]/g, '')
    .replaceAll(/\.\d{3}Z$/, 'Z')
}

function createSessionsCalendar(
  sessionList: (typeof sessions.$inferSelect)[],
  protocol: string,
  host: string | undefined,
  calendarName: string
) {
  const baseUrl =
    host !== undefined
      ? `${protocol}://${host}`
      : (process.env.ORIGIN ?? 'http://localhost:' + PORT)
  const lines = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//Chugmania//Sessions//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    `X-WR-CALNAME:${escapeICSText(calendarName)}`,
    ...sessionList.flatMap(session => createSessionEvent(session, baseUrl)),
    'END:VCALENDAR',
    '',
  ]

  return lines.join('\r\n')
}

function createSessionEvent(
  session: typeof sessions.$inferSelect,
  baseUrl: string
) {
  const start = new Date(session.date)
  const end = new Date(start)
  end.setHours(23, 59, 0, 0)
  const updatedAt = session.updatedAt ?? session.createdAt
  const sequence =
    session.updatedAt &&
    session.updatedAt.getTime() !== session.createdAt.getTime()
      ? Math.floor(session.updatedAt.getTime() / 1000)
      : 0
  const url = `${baseUrl}/sessions`
  const descriptionText = session.description?.trim()
    ? session.description.trim()
    : session.location
      ? `${session.name} @ ${session.location}. Automatically generated by Chugmania.`
      : `${session.name}. Automatically generated by Chugmania.`

  return [
    'BEGIN:VEVENT',
    `UID:${session.id}@chugmania`,
    `DTSTAMP:${formatICSDate(updatedAt)}`,
    `LAST-MODIFIED:${formatICSDate(updatedAt)}`,
    `DTSTART:${formatICSDate(start)}`,
    `DTEND:${formatICSDate(end)}`,
    `SEQUENCE:${sequence}`,
    `SUMMARY:${escapeICSText(session.name)}`,
    session.location
      ? `LOCATION:${escapeICSText(session.location)}`
      : undefined,
    `DESCRIPTION:${escapeICSText(descriptionText)}`,
    `URL:${escapeICSText(url)}`,
    'END:VEVENT',
  ].filter(Boolean)
}

function logError(context: string, error: unknown) {
  const timestamp = new Date().toISOString()
  if (error instanceof Error) {
    console.error(timestamp, context, error.message, error.stack)
  } else {
    console.error(timestamp, context, error)
  }
}
